Section: 
Section: .interp
Section: .note.gnu.property
Section: .note.gnu.build-id
Section: .note.ABI-tag
Section: .gnu.hash
Section: .dynsym
Section: .dynstr
Section: .gnu.version
Section: .gnu.version_r
Section: .rela.dyn
Section: .rela.plt
Section: .init
Section: .plt
Section: .plt.got
Section: .plt.sec
Section: .text
Section: .fini
Section: .rodata
Section: .eh_frame_hdr
Section: .eh_frame
Section: .gcc_except_table
Section: .init_array
Section: .fini_array
Section: .data.rel.ro
Section: .dynamic
Section: .got
Section: .data
Section: .bss
Section: .comment
Section: .debug_aranges
Section: .debug_info
Section: .debug_abbrev
Section: .debug_line
Section: .debug_str
Section: .debug_ranges
Section: .symtab
Section: .strtab
Section: .shstrtab
Failed to find HalideIntrospectionCanary::offset_marker
Realizing Pipeline for target(x86-64-linux-avx-avx2-avx512-avx512_skylake-f16c-fma-sse41)
Inferred argument: int32 vector
Inferred argument: int32 weight
Inferred argument: (void const *) __user_context
Creating initial loop nests...
Injecting realization of { gemv }
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Injecting realization of { sum }
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
        let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
        let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.r4$x, sum.s1.i)*vector(sum.s1.r4$x))
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Lowering after creating initial loop nests:
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.r4$x, sum.s1.i)*vector(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing: (unchanged)

Adding checks for parameters
Lowering after injecting parameter checks: (unchanged)

Computing bounds of each function's value
Bounds on value 0 for func sum are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func gemv are: (void *)neg_inf, (void *)pos_inf
Clamping unsafe data-dependent accesses
Lowering after clamping unsafe data-dependent accesses
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.r4$x, sum.s1.i)*vector(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Performing computation bounds inference...
Lowering after computation bounds inference:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = (4096 + 0) - 1
let sum.s1.r4$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min = gemv.s0.i
    let gemv.s0.i.max = gemv.s0.i.min
    let sum.s1.r4$x.max = (4096 + 0) - 1
    let sum.s1.r4$x.min = 0
    let sum.s1.i.max = gemv.s0.i.max
    let sum.s1.i.min = gemv.s0.i.min
    let sum.s0.i.max = sum.s1.i.max
    let sum.s0.i.min = sum.s1.i.min
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        let sum.s1.r4$x.max = sum.s1.r4$x
        let sum.s1.r4$x.min = sum.s1.r4$x
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.r4$x, sum.s1.i)*vector(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Removing extern loops...
Lowering after removing extern loops: (unchanged)

Performing sliding window optimization...
Lowering after sliding window:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = (4096 + 0) - 1
let sum.s1.r4$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = gemv.s0.i.block.loop_min
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  let gemv.s0.i.thread.thread.loop_min.orig = gemv.s0.i.thread.thread.loop_min
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   let gemv.s0.i.thread.inner_loop.loop_min.orig = gemv.s0.i.thread.inner_loop.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min = gemv.s0.i
    let gemv.s0.i.max = gemv.s0.i.min
    let sum.s1.r4$x.max = (4096 + 0) - 1
    let sum.s1.r4$x.min = 0
    let sum.s1.i.max = gemv.s0.i.max
    let sum.s1.i.min = gemv.s0.i.min
    let sum.s0.i.max = sum.s1.i.max
    let sum.s0.i.min = sum.s1.i.min
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      let sum.s0.i.loop_min.orig = sum.s0.i.loop_min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      let sum.s1.i.loop_min.orig = sum.s1.i.loop_min
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       let sum.s1.r4$x.loop_min.orig = sum.s1.r4$x.loop_min
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        let sum.s1.r4$x.max = sum.s1.r4$x
        let sum.s1.r4$x.min = sum.s1.r4$x
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.r4$x, sum.s1.i)*vector(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Uniquifying variable names...
Lowering after uniquifying variable names:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = (4096 + 0) - 1
let sum.s1.r4$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = gemv.s0.i.block.loop_min
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  let gemv.s0.i.thread.thread.loop_min.orig = gemv.s0.i.thread.thread.loop_min
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   let gemv.s0.i.thread.inner_loop.loop_min.orig = gemv.s0.i.thread.inner_loop.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min_1 = gemv.s0.i
    let gemv.s0.i.max_1 = gemv.s0.i.min_1
    let sum.s1.r4$x.max_1 = (4096 + 0) - 1
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = gemv.s0.i.max_1
    let sum.s1.i.min_1 = gemv.s0.i.min_1
    let sum.s0.i.max_1 = sum.s1.i.max_1
    let sum.s0.i.min_1 = sum.s1.i.min_1
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max_1
      let sum.s0.i.loop_min = sum.s0.i.min_1
      let sum.s0.i.loop_extent = (sum.s0.i.max_1 + 1) - sum.s0.i.min_1
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max_1 - sum.s1.r4$x.min_1) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max_1
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min_1
      let sum.s1.i.loop_max = sum.s1.i.max_1
      let sum.s1.i.loop_min = sum.s1.i.min_1
      let sum.s1.i.loop_extent = (sum.s1.i.max_1 + 1) - sum.s1.i.min_1
      let sum.s0.i.loop_min.orig = sum.s0.i.loop_min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      let sum.s1.i.loop_min.orig = sum.s1.i.loop_min
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       let sum.s1.r4$x.loop_min.orig = sum.s1.r4$x.loop_min
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.r4$x, sum.s1.i)*vector(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Simplifying...
Lowering after first simplification:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r4$x.max_1 = 4095
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r4$x.max_1 = 4095
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r4$x.max_1 = 4095
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.extent_realized = 1
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Adding checks for images
Injecting constraints for gemv.0
Injecting constraints for vector.0
Injecting constraints for weight.0
Injecting constraints for weight.1
Lowering after injecting image checks:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r4$x.loop_extent = 4096
       let sum.s1.r4$x.loop_max = 4095
       let sum.s1.r4$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values: (unchanged)

Performing storage folding optimization...
Lowering after storage folding: (unchanged)

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r4$x.loop_extent = 4096
       let sum.s1.r4$x.loop_max = 4095
       let sum.s1.r4$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Injecting prefetches...
Lowering after injecting prefetches: (unchanged)

Discarding safe promises...
Lowering after discarding safe promises: (unchanged)

Dynamically skipping stages...
skip_stages checking sum
skip_stages can skip sum
Lowering after dynamically skipping stages:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r4$x.loop_extent = 4096
       let sum.s1.r4$x.loop_max = 4095
       let sum.s1.r4$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Forking asynchronous producers...
Lowering after forking asynchronous producers:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Bounding small realizations...
Lowering after bounding small realizations:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(sum.s1.r4$x, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*vector(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Performing storage flattening...
 load call to sum 0
 load call to weight 0
 load call to vector 0
 load call to sum 0
Lowering after storage flattening:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r4$x.loop_extent = 4096
     let sum.s1.r4$x.loop_max = 4095
     let sum.s1.r4$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] + ((int32)weight[(0 + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.1)*weight.stride.pim.1)]*(int32)vector[0 + ((sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0)])
      }
     }
     consume sum {
      gemv[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)]
     }
    }
   }
  }
 }
}

Adding atomic mutex allocation...
Lowering after adding atomic mutex allocation: (unchanged)

Unpacking buffer arguments...
Lowering after unpacking buffer arguments:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = (4095 + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = (4095 + 1) - 0
let weight.min.0.required = 0
let weight.stride.0.required = 1
let weight.extent.1.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.1.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let vector.min.0.constrained = 0
let vector.extent.0.constrained = 4096
let weight.stride.0.constrained = 1
let weight.min.0.constrained = 0
let weight.extent.0.constrained = 4096
let weight.stride.1.constrained = 4096
let weight.min.1.constrained = 0
let weight.extent.1.constrained = 8192
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = 0
let vector.extent.0.proposed = 4096
let weight.stride.0.proposed = 1
let weight.min.0.proposed = 0
let weight.extent.0.proposed = 4096
let weight.stride.1.proposed = 4096
let weight.min.1.proposed = 0
let weight.extent.1.proposed = 8192
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(vector.min.0 == vector.min.0.constrained, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", vector.min.0.constrained))
 assert(vector.extent.0 == vector.extent.0.constrained, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", vector.extent.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 assert(weight.min.0 == weight.min.0.constrained, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", weight.min.0.constrained))
 assert(weight.extent.0 == weight.extent.0.constrained, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", weight.extent.0.constrained))
 assert(weight.stride.1 == weight.stride.1.constrained, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", weight.stride.1.constrained))
 assert(weight.min.1 == weight.min.1.constrained, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", weight.min.1.constrained))
 assert(weight.extent.1 == weight.extent.1.constrained, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", weight.extent.1.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0.constrained)
 let weight.total_extent.0 = int64(weight.extent.0.constrained)
 let weight.total_extent.1 = int64(weight.extent.1.constrained)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0.constrained)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0.constrained)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1.constrained)*int64(weight.stride.1.constrained)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r4$x.loop_extent = 4096
     let sum.s1.r4$x.loop_max = 4095
     let sum.s1.r4$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] + (weight[(0 + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.1)*weight.stride.pim.1)]*vector[0 + ((sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0)])
      }
     }
     consume sum {
      gemv[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)]
     }
    }
   }
  }
 }
}

Skipping rewriting memoized allocations...
Simplifying...
Lowering after second simplifcation:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 0
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(int64(gemv.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(int64(gemv.extent.0)), (uint64)2147483647))
 0
 0
 0
 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}

Reduce prefetch dimension...
Lowering after reduce prefetch dimension: (unchanged)

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 0
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(int64(gemv.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(int64(gemv.extent.0)), (uint64)2147483647))
 0
 0
 0
 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}

Unrolling...
Lowering after unrolling: (unchanged)

Vectorizing...
Lowering after vectorizing:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}

Detecting vector interleavings...
Lowering after rewriting vector interleavings:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}

Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}

Staging strided loads...
Lowering after staging strided loads: (unchanged)

Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}

Rebasing loops to zero...
Lowering after rebasing loops to zero:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0]
     }
    }
   }
  }
 }
}


Hoisting loop invariant if statements...
Lowering after hoisting loop invariant if statements: (unchanged)

Injecting early frees...
Lowering after injecting early frees:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Bounding small allocations...
Lowering after bounding small allocations:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      gemv[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - gemv.min.pim.0)*gemv.stride.pim.0] = sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Simplifying...
Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(let t10 = (min(gemv.extent.0, 2048) + gemv.min.0) in (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= t10) && ((max(gemv.extent.0, 2048) + t10) <= 10240))), let t11 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, t11 + -2048, (max(gemv.extent.0, 2048) + t11) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), let t12 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, t12 + -2048, (max(gemv.extent.0, 2048) + t12) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)) - sum.min.pim.0)*sum.stride.pim.0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       let t13 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)
       let t14 = (t13 - sum.min.pim.0)*sum.stride.pim.0
       sum[t14] = sum[t14] + (weight[((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0) + ((t13 - weight.min.pim.1)*weight.stride.pim.1)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      let t15 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)
      gemv[(t15 - gemv.min.pim.0)*gemv.stride.pim.0] = sum[(t15 - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Flattening nested ramps...
Lowering after flattening nested ramps: (unchanged)

Removing dead allocations and moving loop invariant code...
Lowering after removing dead allocations and hoisting loop invariants:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let t20 = (gemv.extent.0 + 2047)/2048
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, t20) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   let t22 = (gemv.min.0 - sum.min.pim.0) + gemv.s0.i.thread.base.s
   let t23 = gemv.min.0 + gemv.s0.i.thread.base.s
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let t26 = gemv.s0.i.thread.thread*128
    let t25 = t23 + t26
    let t24 = t22 + t26
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[(gemv.s0.i.thread.inner_loop + t24)*sum.stride.pim.0] = 0
      let t27 = gemv.s0.i.thread.inner_loop + t25
      for (sum.s1.r4$x, 0, 4096) {
       let t19 = (t27 - sum.min.pim.0)*sum.stride.pim.0
       sum[t19] = sum[t19] + (weight[((t27 - weight.min.pim.1)*weight.stride.pim.1) + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      let t15 = gemv.s0.i.thread.inner_loop + t25
      gemv[(t15 - gemv.min.pim.0)*gemv.stride.pim.0] = sum[(t15 - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Finding intrinsics...
Lowering after finding intrinsics:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t28 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t28 + -1, gemv.min.0, t28 + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let t20 = (gemv.extent.0 + 2047)/2048
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, t20) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   let t22 = (gemv.min.0 - sum.min.pim.0) + gemv.s0.i.thread.base.s
   let t23 = gemv.min.0 + gemv.s0.i.thread.base.s
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let t26 = gemv.s0.i.thread.thread*128
    let t25 = t23 + t26
    let t24 = t22 + t26
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[(gemv.s0.i.thread.inner_loop + t24)*sum.stride.pim.0] = 0
      let t27 = gemv.s0.i.thread.inner_loop + t25
      for (sum.s1.r4$x, 0, 4096) {
       let t19 = (t27 - sum.min.pim.0)*sum.stride.pim.0
       sum[t19] = sum[t19] + (weight[((t27 - weight.min.pim.1)*weight.stride.pim.1) + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      let t15 = gemv.s0.i.thread.inner_loop + t25
      gemv[(t15 - gemv.min.pim.0)*gemv.stride.pim.0] = sum[(t15 - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Hoisting prefetches...
Lowering after hoisting prefetches:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t28 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t28 + -1, gemv.min.0, t28 + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let t20 = (gemv.extent.0 + 2047)/2048
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, t20) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   let t22 = (gemv.min.0 - sum.min.pim.0) + gemv.s0.i.thread.base.s
   let t23 = gemv.min.0 + gemv.s0.i.thread.base.s
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let t26 = gemv.s0.i.thread.thread*128
    let t25 = t23 + t26
    let t24 = t22 + t26
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[(gemv.s0.i.thread.inner_loop + t24)*sum.stride.pim.0] = 0
      let t27 = gemv.s0.i.thread.inner_loop + t25
      for (sum.s1.r4$x, 0, 4096) {
       let t19 = (t27 - sum.min.pim.0)*sum.stride.pim.0
       sum[t19] = sum[t19] + (weight[((t27 - weight.min.pim.1)*weight.stride.pim.1) + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      let t15 = gemv.s0.i.thread.inner_loop + t25
      gemv[(t15 - gemv.min.pim.0)*gemv.stride.pim.0] = sum[(t15 - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}

Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t28 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t28 + -1, gemv.min.0, t28 + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let t20 = (gemv.extent.0 + 2047)/2048
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, t20) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   let t22 = (gemv.min.0 - sum.min.pim.0) + gemv.s0.i.thread.base.s
   let t23 = gemv.min.0 + gemv.s0.i.thread.base.s
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let t26 = gemv.s0.i.thread.thread*128
    let t25 = t23 + t26
    let t24 = t22 + t26
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[(gemv.s0.i.thread.inner_loop + t24)*sum.stride.pim.0] = 0
      let t27 = gemv.s0.i.thread.inner_loop + t25
      for (sum.s1.r4$x, 0, 4096) {
       let t19 = (t27 - sum.min.pim.0)*sum.stride.pim.0
       sum[t19] = sum[t19] + (weight[((t27 - weight.min.pim.1)*weight.stride.pim.1) + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      let t15 = gemv.s0.i.thread.inner_loop + t25
      gemv[(t15 - gemv.min.pim.0)*gemv.stride.pim.0] = sum[(t15 - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}


Skipping Hexagon offload...
Skipping GPU offload...
Skipping PIM offload...
Lowering Parallel Tasks...
Lowering after generating parallel tasks and closures:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0, 0, 8192, 4096, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t28 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t28 + -1, gemv.min.0, t28 + -1))
 assert((vector.min.0 <= 0) && (4096 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, 4095, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= 0) && (4096 <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, 0, 4095, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.1 + weight.min.1)), halide_error_access_out_of_bounds("Input buffer weight", 1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(vector.min.0 == 0, halide_error_constraint_violated("vector.min.0", vector.min.0, "0", 0))
 assert(vector.extent.0 == 4096, halide_error_constraint_violated("vector.extent.0", vector.extent.0, "4096", 4096))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 assert(weight.min.0 == 0, halide_error_constraint_violated("weight.min.0", weight.min.0, "0", 0))
 assert(weight.extent.0 == 4096, halide_error_constraint_violated("weight.extent.0", weight.extent.0, "4096", 4096))
 assert(weight.stride.1 == 4096, halide_error_constraint_violated("weight.stride.1", weight.stride.1, "4096", 4096))
 assert(weight.min.1 == 0, halide_error_constraint_violated("weight.min.1", weight.min.1, "0", 0))
 assert(weight.extent.1 == 8192, halide_error_constraint_violated("weight.extent.1", weight.extent.1, "8192", 8192))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let t20 = (gemv.extent.0 + 2047)/2048
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, t20) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   let t22 = (gemv.min.0 - sum.min.pim.0) + gemv.s0.i.thread.base.s
   let t23 = gemv.min.0 + gemv.s0.i.thread.base.s
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let t26 = gemv.s0.i.thread.thread*128
    let t25 = t23 + t26
    let t24 = t22 + t26
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[(gemv.s0.i.thread.inner_loop + t24)*sum.stride.pim.0] = 0
      let t27 = gemv.s0.i.thread.inner_loop + t25
      for (sum.s1.r4$x, 0, 4096) {
       let t19 = (t27 - sum.min.pim.0)*sum.stride.pim.0
       sum[t19] = sum[t19] + (weight[((t27 - weight.min.pim.1)*weight.stride.pim.1) + ((sum.s1.r4$x - weight.min.pim.0)*weight.stride.pim.0)]*vector[(sum.s1.r4$x - vector.min.pim.0)*vector.stride.pim.0])
      }
     }
     consume sum {
      let t15 = gemv.s0.i.thread.inner_loop + t25
      gemv[(t15 - gemv.min.pim.0)*gemv.stride.pim.0] = sum[(t15 - sum.min.pim.0)*sum.stride.pim.0]
     }
     free sum
    }
   }
  }
 }
}


jit-compiling for: target(x86-64-linux-avx-avx2-avx512-avx512_skylake-f16c-fma-jit-sse41-user_context)
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function gemv...
Generating llvm bitcode for function gemv...
Internal Error at /root/dev/halide-pim/src/CodeGen_LLVM.cpp:3714 triggered by user code at : Unknown type of For node. Only Serial and Parallel For nodes should survive down to codegen.
Aborted (core dumped)
