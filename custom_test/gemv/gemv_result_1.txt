Section: 
Section: .interp
Section: .note.gnu.property
Section: .note.gnu.build-id
Section: .note.ABI-tag
Section: .gnu.hash
Section: .dynsym
Section: .dynstr
Section: .gnu.version
Section: .gnu.version_r
Section: .rela.dyn
Section: .rela.plt
Section: .init
Section: .plt
Section: .plt.got
Section: .plt.sec
Section: .text
Section: .fini
Section: .rodata
Section: .eh_frame_hdr
Section: .eh_frame
Section: .gcc_except_table
Section: .init_array
Section: .fini_array
Section: .data.rel.ro
Section: .dynamic
Section: .got
Section: .data
Section: .bss
Section: .comment
Section: .debug_aranges
Section: .debug_info
Section: .debug_abbrev
Section: .debug_line
Section: .debug_str
Section: .debug_ranges
Section: .symtab
Section: .strtab
Section: .shstrtab
Failed to find HalideIntrospectionCanary::offset_marker
Inferred argument: int32 b0
Inferred argument: int32 b1
Inferred argument: (void const *) __user_context
Creating initial loop nests...
Injecting realization of { gemv }
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Injecting realization of { sum }
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
        let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
        let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + intermediate(sum.s1.i, sum.s1.r4$x)
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Inlining intermediate
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
        let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
        let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + (b0(sum.s1.i, sum.s1.r4$x)*b1(sum.s1.r4$x))
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Lowering after creating initial loop nests:
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        sum(sum.s1.i) = sum(sum.s1.i) + (b0(sum.s1.i, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing: (unchanged)

Adding checks for parameters
Lowering after injecting parameter checks: (unchanged)

Computing bounds of each function's value
Bounds on value 0 for func intermediate are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func sum are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func gemv are: (void *)neg_inf, (void *)pos_inf
Clamping unsafe data-dependent accesses
Lowering after clamping unsafe data-dependent accesses
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        sum(sum.s1.i) = sum(sum.s1.i) + (b0(sum.s1.i, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Performing computation bounds inference...
Lowering after computation bounds inference:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = (4096 + 0) - 1
let sum.s1.r4$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min = gemv.s0.i
    let gemv.s0.i.max = gemv.s0.i.min
    let sum.s1.r4$x.max = (4096 + 0) - 1
    let sum.s1.r4$x.min = 0
    let sum.s1.i.max = gemv.s0.i.max
    let sum.s1.i.min = gemv.s0.i.min
    let sum.s0.i.max = sum.s1.i.max
    let sum.s0.i.min = sum.s1.i.min
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        let sum.s1.r4$x.max = sum.s1.r4$x
        let sum.s1.r4$x.min = sum.s1.r4$x
        sum(sum.s1.i) = sum(sum.s1.i) + (b0(sum.s1.i, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Removing extern loops...
Lowering after removing extern loops: (unchanged)

Performing sliding window optimization...
Lowering after sliding window:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = (4096 + 0) - 1
let sum.s1.r4$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = gemv.s0.i.block.loop_min
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  let gemv.s0.i.thread.thread.loop_min.orig = gemv.s0.i.thread.thread.loop_min
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   let gemv.s0.i.thread.inner_loop.loop_min.orig = gemv.s0.i.thread.inner_loop.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min = gemv.s0.i
    let gemv.s0.i.max = gemv.s0.i.min
    let sum.s1.r4$x.max = (4096 + 0) - 1
    let sum.s1.r4$x.min = 0
    let sum.s1.i.max = gemv.s0.i.max
    let sum.s1.i.min = gemv.s0.i.min
    let sum.s0.i.max = sum.s1.i.max
    let sum.s0.i.min = sum.s1.i.min
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max - sum.s1.r4$x.min) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      let sum.s0.i.loop_min.orig = sum.s0.i.loop_min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      let sum.s1.i.loop_min.orig = sum.s1.i.loop_min
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       let sum.s1.r4$x.loop_min.orig = sum.s1.r4$x.loop_min
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        let sum.s1.r4$x.max = sum.s1.r4$x
        let sum.s1.r4$x.min = sum.s1.r4$x
        sum(sum.s1.i) = sum(sum.s1.i) + (b0(sum.s1.i, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Uniquifying variable names...
Lowering after uniquifying variable names:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = (4096 + 0) - 1
let sum.s1.r4$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = gemv.s0.i.block.loop_min
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  let gemv.s0.i.thread.thread.loop_min.orig = gemv.s0.i.thread.thread.loop_min
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   let gemv.s0.i.thread.inner_loop.loop_min.orig = gemv.s0.i.thread.inner_loop.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min_1 = gemv.s0.i
    let gemv.s0.i.max_1 = gemv.s0.i.min_1
    let sum.s1.r4$x.max_1 = (4096 + 0) - 1
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = gemv.s0.i.max_1
    let sum.s1.i.min_1 = gemv.s0.i.min_1
    let sum.s0.i.max_1 = sum.s1.i.max_1
    let sum.s0.i.min_1 = sum.s1.i.min_1
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max_1
      let sum.s0.i.loop_min = sum.s0.i.min_1
      let sum.s0.i.loop_extent = (sum.s0.i.max_1 + 1) - sum.s0.i.min_1
      let sum.s1.r4$x.loop_extent = (sum.s1.r4$x.max_1 - sum.s1.r4$x.min_1) + 1
      let sum.s1.r4$x.loop_max = sum.s1.r4$x.max_1
      let sum.s1.r4$x.loop_min = sum.s1.r4$x.min_1
      let sum.s1.i.loop_max = sum.s1.i.max_1
      let sum.s1.i.loop_min = sum.s1.i.min_1
      let sum.s1.i.loop_extent = (sum.s1.i.max_1 + 1) - sum.s1.i.min_1
      let sum.s0.i.loop_min.orig = sum.s0.i.loop_min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      let sum.s1.i.loop_min.orig = sum.s1.i.loop_min
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       let sum.s1.r4$x.loop_min.orig = sum.s1.r4$x.loop_min
       for (sum.s1.r4$x, sum.s1.r4$x.loop_min, sum.s1.r4$x.loop_extent) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(sum.s1.i) = sum(sum.s1.i) + (b0(sum.s1.i, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Simplifying...
Lowering after first simplification:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r4$x.max_1 = 4095
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r4$x.max_1 = 4095
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r4$x.max_1 = 4095
    let sum.s1.r4$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.extent_realized = 1
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Adding checks for images
Injecting constraints for b0.0
Injecting constraints for b0.1
Injecting constraints for b1.0
Injecting constraints for gemv.0
Lowering after injecting image checks:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r4$x.loop_extent = 4096
       let sum.s1.r4$x.loop_max = 4095
       let sum.s1.r4$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values: (unchanged)

Performing storage folding optimization...
Lowering after storage folding: (unchanged)

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r4$x.loop_extent = 4096
       let sum.s1.r4$x.loop_max = 4095
       let sum.s1.r4$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Injecting prefetches...
Lowering after injecting prefetches: (unchanged)

Discarding safe promises...
Lowering after discarding safe promises: (unchanged)

Dynamically skipping stages...
skip_stages checking sum
skip_stages can skip sum
skip_stages checking intermediate
Lowering after dynamically skipping stages:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r4$x.loop_extent = 4096
       let sum.s1.r4$x.loop_max = 4095
       let sum.s1.r4$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Forking asynchronous producers...
Lowering after forking asynchronous producers:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Canonicalizing GPU var names...
Lowering after canonicalizing GPU var names:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Bounding small realizations...
Lowering after bounding small realizations:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r4$x.loop_extent = 4096
      let sum.s1.r4$x.loop_max = 4095
      let sum.s1.r4$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r4$x.loop_min.orig = 0
       for (sum.s1.r4$x, 0, 4096) {
        let sum.s1.r4$x.max_2 = sum.s1.r4$x
        let sum.s1.r4$x.min_2 = sum.s1.r4$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (b0(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r4$x)*b1(sum.s1.r4$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Performing storage flattening...
 load call to sum 0
 load call to b0 0
 load call to b1 0
 load call to sum 0
Lowering after storage flattening:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert((uint32)b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", (uint32)b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert((uint32)b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", (uint32)b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r4$x.loop_extent = 4096
     let sum.s1.r4$x.loop_max = 4095
     let sum.s1.r4$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] + ((int32)b0[((0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*b0.stride.0)) + (sum.s1.r4$x*b0.stride.1)) - ((0 + (b0.min.0*b0.stride.0)) + (b0.min.1*b0.stride.1))]*(int32)b1[(0 + (sum.s1.r4$x*b1.stride.0)) - (0 + (b1.min.0*b1.stride.0))])
      }
     }
     consume sum {
      gemv[(0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*gemv.stride.0)) - (0 + (gemv.min.0*gemv.stride.0))] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)]
     }
    }
   }
  }
 }
}

Adding atomic mutex allocation...
Lowering after adding atomic mutex allocation: (unchanged)

Unpacking buffer arguments...
Lowering after unpacking buffer arguments:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r4$x.loop_extent = 4096
     let sum.s1.r4$x.loop_max = 4095
     let sum.s1.r4$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] + (b0[((0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*b0.stride.0)) + (sum.s1.r4$x*b0.stride.1)) - ((0 + (b0.min.0*b0.stride.0)) + (b0.min.1*b0.stride.1))]*b1[(0 + (sum.s1.r4$x*b1.stride.0)) - (0 + (b1.min.0*b1.stride.0))])
      }
     }
     consume sum {
      gemv[(0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*gemv.stride.0)) - (0 + (gemv.min.0*gemv.stride.0))] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)]
     }
    }
   }
  }
 }
}

Skipping rewriting memoized allocations...
Selecting a GPU API for GPU loops...
Lowering after selecting a GPU API:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r4$x.loop_extent = 4096
     let sum.s1.r4$x.loop_max = 4095
     let sum.s1.r4$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] + (b0[((0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*b0.stride.0)) + (sum.s1.r4$x*b0.stride.1)) - ((0 + (b0.min.0*b0.stride.0)) + (b0.min.1*b0.stride.1))]*b1[(0 + (sum.s1.r4$x*b1.stride.0)) - (0 + (b1.min.0*b1.stride.0))])
      }
     }
     consume sum {
      gemv[(0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*gemv.stride.0)) - (0 + (gemv.min.0*gemv.stride.0))] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)]
     }
    }
   }
  }
 }
}

Injecting host <-> dev buffer copies...
Lowering after injecting host <-> dev buffer copies:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r4$x.max = 4095
let sum.s1.r4$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let b0.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let b0.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let b0.stride.0.required = 1
let b0.extent.1.required = (4095 + 1) - 0
let b0.min.1.required = 0
let b0.stride.1.required = b0.stride.0.required*b0.extent.0.required
let b1.extent.0.required = (4095 + 1) - 0
let b1.min.0.required = 0
let b1.stride.0.required = 1
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let b0.stride.0.constrained = 1
let b0.min.0.constrained = 0
let b0.extent.0.constrained = 8192
let b0.stride.1.constrained = 8192
let b0.min.1.constrained = 0
let b0.extent.1.constrained = 4096
let b1.stride.0.constrained = 1
let b1.min.0.constrained = 0
let b1.extent.0.constrained = 4096
let gemv.stride.0.constrained = 1
let b0.stride.0.proposed = 1
let b0.min.0.proposed = 0
let b0.extent.0.proposed = 8192
let b0.stride.1.proposed = 8192
let b0.min.1.proposed = 0
let b0.extent.1.proposed = 4096
let b1.stride.0.proposed = 1
let b1.min.0.proposed = 0
let b1.extent.0.proposed = 4096
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.0.proposed <= b0.min.0.required) && (((b0.min.0.proposed + b0.extent.0.proposed) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, b0.min.0.proposed, (b0.min.0.proposed + b0.extent.0.proposed) - 1, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((b0.min.1.proposed <= b0.min.1.required) && (((b0.min.1.proposed + b0.extent.1.proposed) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b0", 1, b0.min.1.proposed, (b0.min.1.proposed + b0.extent.1.proposed) - 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer) || ((b1.min.0.proposed <= b1.min.0.required) && (((b1.min.0.proposed + b1.extent.0.proposed) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer b1", 0, b1.min.0.proposed, (b1.min.0.proposed + b1.extent.0.proposed) - 1, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(b0.min.0.proposed, b0.extent.0.proposed, b0.stride.0.proposed, 0, b0.min.1.proposed, b0.extent.1.proposed, b0.stride.1.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(b1.min.0.proposed, b1.extent.0.proposed, b1.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((b0.min.0 <= b0.min.0.required) && (((b0.min.0 + b0.extent.0) - 1) >= ((b0.min.0.required + b0.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 0, b0.min.0.required, (b0.min.0.required + b0.extent.0.required) - 1, b0.min.0, (b0.min.0 + b0.extent.0) - 1))
 assert(b0.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= b0.min.1.required) && (((b0.min.1 + b0.extent.1) - 1) >= ((b0.min.1.required + b0.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer b0", 1, b0.min.1.required, (b0.min.1.required + b0.extent.1.required) - 1, b0.min.1, (b0.min.1 + b0.extent.1) - 1))
 assert(b0.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= b1.min.0.required) && (((b1.min.0 + b1.extent.0) - 1) >= ((b1.min.0.required + b1.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer b1", 0, b1.min.0.required, (b1.min.0.required + b1.extent.0.required) - 1, b1.min.0, (b1.min.0 + b1.extent.0) - 1))
 assert(b1.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert(b0.stride.0 == b0.stride.0.constrained, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", b0.stride.0.constrained))
 assert(b0.min.0 == b0.min.0.constrained, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", b0.min.0.constrained))
 assert(b0.extent.0 == b0.extent.0.constrained, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", b0.extent.0.constrained))
 assert(b0.stride.1 == b0.stride.1.constrained, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", b0.stride.1.constrained))
 assert(b0.min.1 == b0.min.1.constrained, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", b0.min.1.constrained))
 assert(b0.extent.1 == b0.extent.1.constrained, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", b0.extent.1.constrained))
 assert(b1.stride.0 == b1.stride.0.constrained, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", b1.stride.0.constrained))
 assert(b1.min.0 == b1.min.0.constrained, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", b1.min.0.constrained))
 assert(b1.extent.0 == b1.extent.0.constrained, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", b1.extent.0.constrained))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 let b0.total_extent.0 = int64(b0.extent.0.constrained)
 let b0.total_extent.1 = int64(b0.extent.1.constrained)*b0.total_extent.0
 let b1.total_extent.0 = int64(b1.extent.0.constrained)
 let gemv.total_extent.0 = int64(gemv.extent.0)
 assert((uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.0.constrained)*int64(b0.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b0", (uint64)abs(int64(b0.extent.1.constrained)*int64(b0.stride.1.constrained)), (uint64)2147483647))
 assert(b0.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("b0", b0.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("b1", (uint64)abs(int64(b1.extent.0.constrained)*int64(b1.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r4$x.max_1 = 4095
     let sum.s1.r4$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r4$x.loop_extent = 4096
     let sum.s1.r4$x.loop_max = 4095
     let sum.s1.r4$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = 0
      let sum.s1.r4$x.loop_min.orig = 0
      for (sum.s1.r4$x, 0, 4096) {
       let sum.s1.r4$x.max_2 = sum.s1.r4$x
       let sum.s1.r4$x.min_2 = sum.s1.r4$x
       sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)] + (b0[((0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*b0.stride.0)) + (sum.s1.r4$x*b0.stride.1)) - ((0 + (b0.min.0*b0.stride.0)) + (b0.min.1*b0.stride.1))]*b1[(0 + (sum.s1.r4$x*b1.stride.0)) - (0 + (b1.min.0*b1.stride.0))])
      }
     }
     consume sum {
      gemv[(0 + ((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)*gemv.stride.0)) - (0 + (gemv.min.0*gemv.stride.0))] = sum[0 + (((((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.0)*sum.stride.0)]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Selecting a GPU API for extern stages...
Lowering after selecting a GPU API for extern stages: (unchanged)

Simplifying...
Lowering after second simplifcation:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
0
0
0
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 0
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(int64(gemv.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(int64(gemv.extent.0)), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.0] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Reduce prefetch dimension...
Lowering after reduce prefetch dimension: (unchanged)

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
0
0
0
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 0
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(int64(gemv.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(int64(gemv.extent.0)), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.0] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Unrolling...
Lowering after unrolling: (unchanged)

Vectorizing...
Lowering after vectorizing:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.0] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Detecting vector interleavings...
Lowering after rewriting vector interleavings:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.0] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Staging strided loads...
Lowering after staging strided loads: (unchanged)

Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Rebasing loops to zero...
Lowering after rebasing loops to zero:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}


Hoisting loop invariant if statements...
Lowering after hoisting loop invariant if statements: (unchanged)

Injecting early frees...
Lowering after injecting early frees:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
     free sum
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
     free sum
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Bounding small allocations...
Lowering after bounding small allocations:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) <= 10240)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
     free sum
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Simplifying...
Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(let t9 = (min(gemv.extent.0, 2048) + gemv.min.0) in (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= t9) && ((max(gemv.extent.0, 2048) + t9) <= 10240))), let t10 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, t10 + -2048, (max(gemv.extent.0, 2048) + t10) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(let t11 = (min(gemv.extent.0, 2048) + gemv.min.0) in (((b0.min.0 + 2048) <= t11) && (((max(gemv.extent.0, 2048) + t11) + -2048) <= (b0.extent.0 + b0.min.0))), let t12 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_access_out_of_bounds("Input buffer b0", 0, t12 + -2048, (max(gemv.extent.0, 2048) + t12) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), let t13 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, t13 + -2048, (max(gemv.extent.0, 2048) + t13) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
     free sum
    }
   }
  }
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Flattening nested ramps...
Lowering after flattening nested ramps: (unchanged)

Transforming data layout for UPMEM PIM...
lowering after transforming layout:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(let t9 = (min(gemv.extent.0, 2048) + gemv.min.0) in (!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= t9) && ((max(gemv.extent.0, 2048) + t9) <= 10240))), let t10 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, t10 + -2048, (max(gemv.extent.0, 2048) + t10) + -2049))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(let t11 = (min(gemv.extent.0, 2048) + gemv.min.0) in (((b0.min.0 + 2048) <= t11) && (((max(gemv.extent.0, 2048) + t11) + -2048) <= (b0.extent.0 + b0.min.0))), let t12 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_access_out_of_bounds("Input buffer b0", 0, t12 + -2048, (max(gemv.extent.0, 2048) + t12) + -2049, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), let t13 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, t13 + -2048, (max(gemv.extent.0, 2048) + t13) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load(((((gemv.extent.0 + 2047)/2048)*1)*1)*1, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   for (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let dpu_idx = gemv.s0.i.block.__bank_id_x
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     for (sum.s1.r4$x, 0, 4096) {
      halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)b0.buffer, (sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s)))
      halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)b1.buffer, sum.s1.r4$x)
     }
     halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s)
    }
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + (((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + (gemv.min.0 + gemv.s0.i.thread.base.s))]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base.s] = sum[0]
     }
     free sum
    }
   }
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Removing dead allocations and moving loop invariant code...
Lowering after removing dead allocations and hoisting loop invariants:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert(2048 <= gemv.extent.0, halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t23 = gemv.s0.i.thread.thread*128
  let t20 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t19 = (gemv.extent.0 + 2047)/2048
  let t21 = gemv.min.0 + t23
  for (gemv.s0.i.block.__bank_id_x, 0, t19) {
   let t25 = t20 + t23
   let t24 = t20 + t21
   for (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let t26 = gemv.s0.i.thread.inner_loop + t24
     for (sum.s1.r4$x, 0, 4096) {
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b0.buffer, (sum.s1.r4$x*8192) + t26)
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b1.buffer, sum.s1.r4$x)
     }
     halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.inner_loop + t25)
    }
   }
  }
  let t31 = gemv.s0.i.thread.thread*128
  let t28 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t27 = (gemv.extent.0 + 2047)/2048
  let t29 = gemv.min.0 + t31
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t27) {
   let t33 = t28 + t31
   let t32 = t28 + t29
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t34 = gemv.s0.i.thread.inner_loop + t32
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + t34]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t33] = sum[0]
     }
     free sum
    }
   }
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Finding intrinsics...
Lowering after finding intrinsics:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert(2048 <= gemv.extent.0, let t35 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t35 + -1, gemv.min.0, t35 + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t23 = gemv.s0.i.thread.thread*128
  let t20 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t19 = (gemv.extent.0 + 2047)/2048
  let t21 = gemv.min.0 + t23
  for (gemv.s0.i.block.__bank_id_x, 0, t19) {
   let t25 = t20 + t23
   let t24 = t20 + t21
   for (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let t26 = gemv.s0.i.thread.inner_loop + t24
     for (sum.s1.r4$x, 0, 4096) {
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b0.buffer, (sum.s1.r4$x*8192) + t26)
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b1.buffer, sum.s1.r4$x)
     }
     halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.inner_loop + t25)
    }
   }
  }
  let t31 = gemv.s0.i.thread.thread*128
  let t28 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t27 = (gemv.extent.0 + 2047)/2048
  let t29 = gemv.min.0 + t31
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t27) {
   let t33 = t28 + t31
   let t32 = t28 + t29
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t34 = gemv.s0.i.thread.inner_loop + t32
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + t34]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t33] = sum[0]
     }
     free sum
    }
   }
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Hoisting prefetches...
Lowering after hoisting prefetches:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert(2048 <= gemv.extent.0, let t35 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t35 + -1, gemv.min.0, t35 + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t23 = gemv.s0.i.thread.thread*128
  let t20 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t19 = (gemv.extent.0 + 2047)/2048
  let t21 = gemv.min.0 + t23
  for (gemv.s0.i.block.__bank_id_x, 0, t19) {
   let t25 = t20 + t23
   let t24 = t20 + t21
   for (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let t26 = gemv.s0.i.thread.inner_loop + t24
     for (sum.s1.r4$x, 0, 4096) {
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b0.buffer, (sum.s1.r4$x*8192) + t26)
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b1.buffer, sum.s1.r4$x)
     }
     halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.inner_loop + t25)
    }
   }
  }
  let t31 = gemv.s0.i.thread.thread*128
  let t28 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t27 = (gemv.extent.0 + 2047)/2048
  let t29 = gemv.min.0 + t31
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t27) {
   let t33 = t28 + t31
   let t32 = t28 + t29
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t34 = gemv.s0.i.thread.inner_loop + t32
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + t34]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t33] = sum[0]
     }
     free sum
    }
   }
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}

Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b1.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b1"))
assert(reinterpret<uint64>((struct halide_buffer_t *)b0.buffer) != (uint64)0, halide_error_buffer_argument_is_null("b0"))
let b0 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b0.buffer)
let b0.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b0.buffer)
let b0.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b0.buffer)
let b0.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 0)
let b0.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 0)
let b0.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 0)
let b0.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)b0.buffer, 1)
let b0.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)b0.buffer, 1)
let b0.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)b0.buffer, 1)
let b1 = (void *)_halide_buffer_get_host((struct halide_buffer_t *)b1.buffer)
let b1.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)b1.buffer)
let b1.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)b1.buffer)
let b1.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)b1.buffer, 0)
let b1.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)b1.buffer, 0)
let b1.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)b1.buffer, 0)
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || ((2048 <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= 8192)), halide_error_constraints_make_required_region_smaller("Input buffer b0", 0, 0, 8191, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b0.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b0.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(0, 8192, 1, 0, 0, 4096, 8192, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)b1.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)b1.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, 4096, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b0.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)b1.buffer)))) {
 assert(b0.type == (uint32)73728, halide_error_bad_type("Input buffer b0", b0.type, (uint32)73728))
 assert(b0.dimensions == 2, halide_error_bad_dimensions("Input buffer b0", b0.dimensions, 2))
 assert(b1.type == (uint32)73728, halide_error_bad_type("Input buffer b1", b1.type, (uint32)73728))
 assert(b1.dimensions == 1, halide_error_bad_dimensions("Input buffer b1", b1.dimensions, 1))
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(((b0.min.0 + 2048) <= (min(gemv.extent.0, 2048) + gemv.min.0)) && ((gemv.extent.0 + gemv.min.0) <= (b0.extent.0 + b0.min.0)), halide_error_access_out_of_bounds("Input buffer b0", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, b0.min.0, (b0.extent.0 + b0.min.0) + -1))
 assert(0 <= b0.extent.0, halide_error_buffer_extents_negative("Input buffer b0", 0, b0.extent.0))
 assert((b0.min.1 <= 0) && (4096 <= (b0.extent.1 + b0.min.1)), halide_error_access_out_of_bounds("Input buffer b0", 1, 0, 4095, b0.min.1, (b0.extent.1 + b0.min.1) + -1))
 assert(0 <= b0.extent.1, halide_error_buffer_extents_negative("Input buffer b0", 1, b0.extent.1))
 assert((b1.min.0 <= 0) && (4096 <= (b1.extent.0 + b1.min.0)), halide_error_access_out_of_bounds("Input buffer b1", 0, 0, 4095, b1.min.0, (b1.extent.0 + b1.min.0) + -1))
 assert(0 <= b1.extent.0, halide_error_buffer_extents_negative("Input buffer b1", 0, b1.extent.0))
 assert(2048 <= gemv.extent.0, let t35 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t35 + -1, gemv.min.0, t35 + -1))
 assert(b0.stride.0 == 1, halide_error_constraint_violated("b0.stride.0", b0.stride.0, "1", 1))
 assert(b0.min.0 == 0, halide_error_constraint_violated("b0.min.0", b0.min.0, "0", 0))
 assert(b0.extent.0 == 8192, halide_error_constraint_violated("b0.extent.0", b0.extent.0, "8192", 8192))
 assert(b0.stride.1 == 8192, halide_error_constraint_violated("b0.stride.1", b0.stride.1, "8192", 8192))
 assert(b0.min.1 == 0, halide_error_constraint_violated("b0.min.1", b0.min.1, "0", 0))
 assert(b0.extent.1 == 4096, halide_error_constraint_violated("b0.extent.1", b0.extent.1, "4096", 4096))
 assert(b1.stride.0 == 1, halide_error_constraint_violated("b1.stride.0", b1.stride.0, "1", 1))
 assert(b1.min.0 == 0, halide_error_constraint_violated("b1.min.0", b1.min.0, "0", 0))
 assert(b1.extent.0 == 4096, halide_error_constraint_violated("b1.extent.0", b1.extent.0, "4096", 4096))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 produce gemv {
  let halide_copy_to_device_result = halide_copy_to_device((struct halide_buffer_t *)b0.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result == 0, halide_copy_to_device_result)
  let halide_copy_to_device_result$1 = halide_copy_to_device((struct halide_buffer_t *)b1.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$1 == 0, halide_copy_to_device_result$1)
  let halide_copy_to_device_result$2 = halide_copy_to_device((struct halide_buffer_t *)gemv.buffer, (struct halide_device_interface_t const *)halide_upmem_device_interface())
  assert(halide_copy_to_device_result$2 == 0, halide_copy_to_device_result$2)
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t23 = gemv.s0.i.thread.thread*128
  let t20 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t19 = (gemv.extent.0 + 2047)/2048
  let t21 = gemv.min.0 + t23
  for (gemv.s0.i.block.__bank_id_x, 0, t19) {
   let t25 = t20 + t23
   let t24 = t20 + t21
   for (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let t26 = gemv.s0.i.thread.inner_loop + t24
     for (sum.s1.r4$x, 0, 4096) {
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b0.buffer, (sum.s1.r4$x*8192) + t26)
      halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)b1.buffer, sum.s1.r4$x)
     }
     halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.inner_loop + t25)
    }
   }
  }
  let t31 = gemv.s0.i.thread.thread*128
  let t28 = min(gemv.s0.i.block*2048, gemv.extent.0 + -2048)
  let t27 = (gemv.extent.0 + 2047)/2048
  let t29 = gemv.min.0 + t31
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t27) {
   let t33 = t28 + t31
   let t32 = t28 + t29
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t34 = gemv.s0.i.thread.inner_loop + t32
      for (sum.s1.r4$x, 0, 4096) {
       sum[0] = sum[0] + (b0[(sum.s1.r4$x*8192) + t34]*b1[sum.s1.r4$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t33] = sum[0]
     }
     free sum
    }
   }
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
  _halide_buffer_set_device_dirty((struct halide_buffer_t *)gemv.buffer, (uint1)1)
 }
}


Skipping Hexagon offload...
Skipping GPU offload...
Offloading PIM loops...
Kernel launch: gemv.s0.i.block.__bank_id_x
Kernel bounds: (1) threads, (t19, 1, 1, 1) banks
var: b0.buffer
var: b1.buffer
var: gemv.buffer
var: t20
var: t21
var: t23
User error triggered at /root/dev/halide-pim/src/OffloadPIMLoops.cpp:136
Condition failed: pim_codegen != nullptr
Subcontext threw exception. Rethrowing...
terminate called after throwing an instance of 'Halide::CompileError'
