Section: 
Section: .interp
Section: .note.gnu.property
Section: .note.gnu.build-id
Section: .note.ABI-tag
Section: .gnu.hash
Section: .dynsym
Section: .dynstr
Section: .gnu.version
Section: .gnu.version_r
Section: .rela.dyn
Section: .rela.plt
Section: .init
Section: .plt
Section: .plt.got
Section: .plt.sec
Section: .text
Section: .fini
Section: .rodata
Section: .eh_frame_hdr
Section: .eh_frame
Section: .gcc_except_table
Section: .init_array
Section: .fini_array
Section: .dynamic
Section: .got
Section: .data
Section: .bss
Section: .comment
Section: .debug_aranges
Section: .debug_info
Section: .debug_abbrev
Section: .debug_line
Section: .debug_str
Section: .debug_ranges
Section: .symtab
Section: .strtab
Section: .shstrtab
Failed to find HalideIntrospectionCanary::offset_marker
Creating initial loop nests...
Injecting realization of { gemv }
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Injecting realization of { sum }
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
        let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
        let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + intermediate(sum.s1.i, sum.s1.r8$x)
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Inlining intermediate
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
        let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
        let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + (weight_im(sum.s1.i, sum.s1.r8$x)*vector_im(sum.s1.r8$x))
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Inlining weight_im
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
        let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
        let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector_im(sum.s1.r8$x))
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Inlining vector_im
for (.__root, 0, 1) {
 produce gemv {
  let gemv.s0.i.loop_max = gemv.s0.i.max
  let gemv.s0.i.loop_min = gemv.s0.i.min
  let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
  let gemv.s0.__outermost.loop_extent = 1
  let gemv.s0.__outermost.loop_max = 0
  let gemv.s0.__outermost.loop_min = 0
  let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
  let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2048 - 1
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
  let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  for (gemv.s0.__outermost, gemv.s0.__outermost.loop_min, gemv.s0.__outermost.loop_extent) {
   pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
    let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
    pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
     let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
     for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
      let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
      let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
      realize sum([sum.i.min_realized, sum.i.extent_realized]) {
       produce sum {
        let sum.s0.i.loop_max = sum.s0.i.max
        let sum.s0.i.loop_min = sum.s0.i.min
        let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
        let sum.s0.__outermost.loop_extent = 1
        let sum.s0.__outermost.loop_max = 0
        let sum.s0.__outermost.loop_min = 0
        let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
        let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
        let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
        let sum.s1.i.loop_max = sum.s1.i.max
        let sum.s1.i.loop_min = sum.s1.i.min
        let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
        let sum.s1.__outermost.loop_extent = 1
        let sum.s1.__outermost.loop_max = 0
        let sum.s1.__outermost.loop_min = 0
        for (sum.s0.__outermost, sum.s0.__outermost.loop_min, sum.s0.__outermost.loop_extent) {
         for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
          sum(sum.s0.i) = 0
         }
        }
        for (sum.s1.__outermost, sum.s1.__outermost.loop_min, sum.s1.__outermost.loop_extent) {
         for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
          for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
           sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector(sum.s1.r8$x))
          }
         }
        }
       }
       consume sum {
        gemv(gemv.s0.i) = sum(gemv.s0.i)
       }
      }
     }
    }
   }
  }
 }
}

Lowering after creating initial loop nests:
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
      let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
      let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing: (unchanged)

Adding checks for parameters
Lowering after injecting parameter checks: (unchanged)

Computing bounds of each function's value
Bounds on value 0 for func vector_im are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func weight_im are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func intermediate are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func sum are: (void *)neg_inf, (void *)pos_inf
Bounds on value 0 for func gemv are: (void *)neg_inf, (void *)pos_inf
Clamping unsafe data-dependent accesses
Lowering after clamping unsafe data-dependent accesses
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
      let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
      let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Performing computation bounds inference...
Lowering after computation bounds inference:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = (weight.extent.1 + 0) - 1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min = gemv.s0.i
    let gemv.s0.i.max = gemv.s0.i.min
    let sum.s1.r8$x.max = (weight.extent.1 + 0) - 1
    let sum.s1.r8$x.min = 0
    let sum.s1.i.max = gemv.s0.i.max
    let sum.s1.i.min = gemv.s0.i.min
    let sum.s0.i.max = sum.s1.i.max
    let sum.s0.i.min = sum.s1.i.min
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
      let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
      let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
        let sum.s1.r8$x.max = sum.s1.r8$x
        let sum.s1.r8$x.min = sum.s1.r8$x
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Removing extern loops...
Lowering after removing extern loops: (unchanged)

Performing sliding window optimization...
Lowering after sliding window:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = (weight.extent.1 + 0) - 1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = gemv.s0.i.block.loop_min
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  let gemv.s0.i.thread.thread.loop_min.orig = gemv.s0.i.thread.thread.loop_min
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   let gemv.s0.i.thread.inner_loop.loop_min.orig = gemv.s0.i.thread.inner_loop.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min = gemv.s0.i
    let gemv.s0.i.max = gemv.s0.i.min
    let sum.s1.r8$x.max = (weight.extent.1 + 0) - 1
    let sum.s1.r8$x.min = 0
    let sum.s1.i.max = gemv.s0.i.max
    let sum.s1.i.min = gemv.s0.i.min
    let sum.s0.i.max = sum.s1.i.max
    let sum.s0.i.min = sum.s1.i.min
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max
      let sum.s0.i.loop_min = sum.s0.i.min
      let sum.s0.i.loop_extent = (sum.s0.i.max + 1) - sum.s0.i.min
      let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max - sum.s1.r8$x.min) + 1
      let sum.s1.r8$x.loop_max = sum.s1.r8$x.max
      let sum.s1.r8$x.loop_min = sum.s1.r8$x.min
      let sum.s1.i.loop_max = sum.s1.i.max
      let sum.s1.i.loop_min = sum.s1.i.min
      let sum.s1.i.loop_extent = (sum.s1.i.max + 1) - sum.s1.i.min
      let sum.s0.i.loop_min.orig = sum.s0.i.loop_min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      let sum.s1.i.loop_min.orig = sum.s1.i.loop_min
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       let sum.s1.r8$x.loop_min.orig = sum.s1.r8$x.loop_min
       for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
        let sum.s1.r8$x.max = sum.s1.r8$x
        let sum.s1.r8$x.min = sum.s1.r8$x
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Uniquifying variable names...
Lowering after uniquifying variable names:
let gemv.s0.i.max = (gemv.min.0 + gemv.extent.0) - 1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = (weight.extent.1 + 0) - 1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = gemv.s0.i.max
let sum.s1.i.min = gemv.s0.i.min
let sum.s0.i.max = sum.s1.i.max
let sum.s0.i.min = sum.s1.i.min
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = gemv.s0.i.max
 let gemv.s0.i.loop_min = gemv.s0.i.min
 let gemv.s0.i.loop_extent = (gemv.s0.i.max + 1) - gemv.s0.i.min
 let gemv.s0.i.block.loop_extent = ((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048
 let gemv.s0.i.block.loop_max = (((gemv.s0.i.loop_max - gemv.s0.i.loop_min) + 2048)/2048) - 1
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2048 - 1
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = ((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128
 let gemv.s0.i.thread.thread.loop_max = (((gemv.s0.i.thread.loop_max - gemv.s0.i.thread.loop_min) + 128)/128) - 1
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 128 - 1
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = gemv.s0.i.block.loop_min
 pim_bank<Default_PIM> (gemv.s0.i.block, gemv.s0.i.block.loop_min, gemv.s0.i.block.loop_extent) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.s0.i.loop_min), gemv.s0.i.loop_max + (1 - 2048))
  let gemv.s0.i.thread.thread.loop_min.orig = gemv.s0.i.thread.thread.loop_min
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, gemv.s0.i.thread.thread.loop_min, gemv.s0.i.thread.thread.loop_extent) {
   let gemv.s0.i.thread.inner_loop.base = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.loop_min
   let gemv.s0.i.thread.inner_loop.loop_min.orig = gemv.s0.i.thread.inner_loop.loop_min
   for (gemv.s0.i.thread.inner_loop, gemv.s0.i.thread.inner_loop.loop_min, gemv.s0.i.thread.inner_loop.loop_extent) {
    let gemv.s0.i.thread = gemv.s0.i.thread.inner_loop.base + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = gemv.s0.i.thread.base + gemv.s0.i.thread
    let gemv.s0.i.min_1 = gemv.s0.i
    let gemv.s0.i.max_1 = gemv.s0.i.min_1
    let sum.s1.r8$x.max_1 = (weight.extent.1 + 0) - 1
    let sum.s1.r8$x.min_1 = 0
    let sum.s1.i.max_1 = gemv.s0.i.max_1
    let sum.s1.i.min_1 = gemv.s0.i.min_1
    let sum.s0.i.max_1 = sum.s1.i.max_1
    let sum.s0.i.min_1 = sum.s1.i.min_1
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = sum.s0.i.max_1
      let sum.s0.i.loop_min = sum.s0.i.min_1
      let sum.s0.i.loop_extent = (sum.s0.i.max_1 + 1) - sum.s0.i.min_1
      let sum.s1.r8$x.loop_extent = (sum.s1.r8$x.max_1 - sum.s1.r8$x.min_1) + 1
      let sum.s1.r8$x.loop_max = sum.s1.r8$x.max_1
      let sum.s1.r8$x.loop_min = sum.s1.r8$x.min_1
      let sum.s1.i.loop_max = sum.s1.i.max_1
      let sum.s1.i.loop_min = sum.s1.i.min_1
      let sum.s1.i.loop_extent = (sum.s1.i.max_1 + 1) - sum.s1.i.min_1
      let sum.s0.i.loop_min.orig = sum.s0.i.loop_min
      for (sum.s0.i, sum.s0.i.loop_min, sum.s0.i.loop_extent) {
       sum(sum.s0.i) = 0
      }
      let sum.s1.i.loop_min.orig = sum.s1.i.loop_min
      for (sum.s1.i, sum.s1.i.loop_min, sum.s1.i.loop_extent) {
       let sum.s1.r8$x.loop_min.orig = sum.s1.r8$x.loop_min
       for (sum.s1.r8$x, sum.s1.r8$x.loop_min, sum.s1.r8$x.loop_extent) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(sum.s1.i) = sum(sum.s1.i) + (weight(sum.s1.i, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
     }
     consume sum {
      gemv(gemv.s0.i) = sum(gemv.s0.i)
     }
    }
   }
  }
 }
}

Simplifying...
Lowering after first simplification:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r8$x.max_1 = weight.extent.1 + -1
    let sum.s1.r8$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r8$x.loop_min.orig = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       let sum.s1.r8$x.max_2 = sum.s1.r8$x
       let sum.s1.r8$x.min_2 = sum.s1.r8$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r8$x.max_1 = weight.extent.1 + -1
    let sum.s1.r8$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r8$x.loop_min.orig = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       let sum.s1.r8$x.max_2 = sum.s1.r8$x
       let sum.s1.r8$x.min_2 = sum.s1.r8$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
add_image_checks_marker()
produce gemv {
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
  let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
  let gemv.s0.i.thread.thread.loop_min.orig = 0
  pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
   let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
   let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
   for (gemv.s0.i.thread.inner_loop, 0, 128) {
    let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
    let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.r8$x.max_1 = weight.extent.1 + -1
    let sum.s1.r8$x.min_1 = 0
    let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
    let sum.i.extent_realized = 1
    realize sum([sum.i.min_realized, sum.i.extent_realized]) {
     produce sum {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
      let sum.s1.r8$x.loop_min.orig = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       let sum.s1.r8$x.max_2 = sum.s1.r8$x
       let sum.s1.r8$x.min_2 = sum.s1.r8$x
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
      }
     }
     consume sum {
      gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
     }
    }
   }
  }
 }
}

Adding checks for images
Injecting constraints for gemv.0
Injecting constraints for vector.0
Injecting constraints for weight.0
Injecting constraints for weight.1
Lowering after injecting image checks:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r8$x.loop_extent = weight.extent.1
       let sum.s1.r8$x.loop_max = weight.extent.1 + -1
       let sum.s1.r8$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values: (unchanged)

Performing storage folding optimization...
Lowering after storage folding: (unchanged)

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r8$x.loop_extent = weight.extent.1
       let sum.s1.r8$x.loop_max = weight.extent.1 + -1
       let sum.s1.r8$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Injecting prefetches...
Lowering after injecting prefetches: (unchanged)

Discarding safe promises...
Lowering after discarding safe promises: (unchanged)

Dynamically skipping stages...
skip_stages checking sum
skip_stages can skip sum
skip_stages checking intermediate
skip_stages checking weight_im
skip_stages checking vector_im
Lowering after dynamically skipping stages:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
  let gemv.s0.i.loop_min = gemv.min.0
  let gemv.s0.i.loop_extent = gemv.extent.0
  let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
  let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
  let gemv.s0.i.block.loop_min = 0
  let gemv.s0.i.thread.loop_extent = 2048
  let gemv.s0.i.thread.loop_max = 2047
  let gemv.s0.i.thread.loop_min = 0
  let gemv.s0.i.thread.thread.loop_extent = 16
  let gemv.s0.i.thread.thread.loop_max = 15
  let gemv.s0.i.thread.thread.loop_min = 0
  let gemv.s0.i.thread.inner_loop.loop_extent = 128
  let gemv.s0.i.thread.inner_loop.loop_max = 127
  let gemv.s0.i.thread.inner_loop.loop_min = 0
  let gemv.s0.i.block.loop_min.orig = 0
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      produce sum {
       let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s0.i.loop_extent = 1
       let sum.s1.r8$x.loop_extent = weight.extent.1
       let sum.s1.r8$x.loop_max = weight.extent.1 + -1
       let sum.s1.r8$x.loop_min = 0
       let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let sum.s1.i.loop_extent = 1
       let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Forking asynchronous producers...
Lowering after forking asynchronous producers:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.loop_extent = 16
 let gemv.s0.i.thread.thread.loop_max = 15
 let gemv.s0.i.thread.thread.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Canonicalizing GPU var names...
Lowering after canonicalizing GPU var names:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.__bank_id_x.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.__bank_id_x.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.__bank_id_x.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.__thread_id_x.loop_extent = 16
 let gemv.s0.i.thread.thread.__thread_id_x.loop_max = 15
 let gemv.s0.i.thread.thread.__thread_id_x.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread.__thread_id_x*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Bounding small realizations...
Lowering after bounding small realizations:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.__bank_id_x.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.__bank_id_x.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.__bank_id_x.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.__thread_id_x.loop_extent = 16
 let gemv.s0.i.thread.thread.__thread_id_x.loop_max = 15
 let gemv.s0.i.thread.thread.__thread_id_x.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread.__thread_id_x*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
 }
}

Transforming data layout for UPMEM PIM...
lowering after transforming layout:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.__bank_id_x.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.__bank_id_x.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.__bank_id_x.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.__thread_id_x.loop_extent = 16
 let gemv.s0.i.thread.thread.__thread_id_x.loop_max = 15
 let gemv.s0.i.thread.thread.__thread_id_x.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load(((((gemv.extent.0 + 2047)/2048)*1)*1)*1, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)vector.buffer, 0, ((weight.extent.1 + -1) - 0) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   for (ii1, 0, (weight.extent.1 + -1) + 1) {
    halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)weight.buffer, (ii1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)) + (((0*128) + 0) + gemv.s0.i.thread.base), ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   }
  }
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let gemv.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let gemv.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let gemv.stride.pim.0 = 1
   let sum.min.pim.0 = sum.min.0
   let sum.extent.pim.0 = sum.extent.0
   let sum.stride.pim.0 = sum.stride.0
   let vector.min.pim.0 = 0
   let vector.extent.pim.0 = ((weight.extent.1 + -1) - 0) + 1
   let vector.stride.pim.0 = 1
   let weight.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let weight.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let weight.stride.pim.0 = 1
   let weight.min.pim.1 = 0
   let weight.extent.pim.1 = ((weight.extent.1 + -1) - 0) + 1
   let weight.stride.pim.1 = 1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread.__thread_id_x*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     realize sum([sum.i.min_realized, sum.i.extent_realized]) {
      let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s0.i.loop_extent = 1
      let sum.s1.r8$x.loop_extent = weight.extent.1
      let sum.s1.r8$x.loop_max = weight.extent.1 + -1
      let sum.s1.r8$x.loop_min = 0
      let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let sum.s1.i.loop_extent = 1
      let t2 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      let t1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
      produce sum {
       sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = 0
       let sum.s1.r8$x.loop_min.orig = 0
       for (sum.s1.r8$x, 0, weight.extent.1) {
        let sum.s1.r8$x.max_2 = sum.s1.r8$x
        let sum.s1.r8$x.min_2 = sum.s1.r8$x
        sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) + (weight(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base, sum.s1.r8$x)*vector(sum.s1.r8$x))
       }
      }
      consume sum {
       gemv(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) = sum(((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base)
      }
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_from(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Performing storage flattening...
 load call to sum 0
 load call to weight 0
     is param:  weight Auto
 load call to vector 0
     is param:  vector Auto
 load call to sum 0
Lowering after storage flattening:
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert((uint32)gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", (uint32)gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert((uint32)vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", (uint32)vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert((uint32)weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", (uint32)weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.__bank_id_x.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.__bank_id_x.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.__bank_id_x.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.__thread_id_x.loop_extent = 16
 let gemv.s0.i.thread.thread.__thread_id_x.loop_max = 15
 let gemv.s0.i.thread.thread.__thread_id_x.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load(((((gemv.extent.0 + 2047)/2048)*1)*1)*1, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)vector.buffer, 0, ((weight.extent.1 + -1) - 0) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   for (ii1, 0, (weight.extent.1 + -1) + 1) {
    halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)weight.buffer, (ii1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)) + (((0*128) + 0) + gemv.s0.i.thread.base), ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   }
  }
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let gemv.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let gemv.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let gemv.stride.pim.0 = 1
   let sum.min.pim.0 = sum.min.0
   let sum.extent.pim.0 = sum.extent.0
   let sum.stride.pim.0 = sum.stride.0
   let vector.min.pim.0 = 0
   let vector.extent.pim.0 = ((weight.extent.1 + -1) - 0) + 1
   let vector.stride.pim.0 = 1
   let weight.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let weight.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let weight.stride.pim.0 = 1
   let weight.min.pim.1 = 0
   let weight.extent.pim.1 = ((weight.extent.1 + -1) - 0) + 1
   let weight.stride.pim.1 = 1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread.__thread_id_x*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r8$x.loop_extent = weight.extent.1
     let sum.s1.r8$x.loop_max = weight.extent.1 + -1
     let sum.s1.r8$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = 0
      let sum.s1.r8$x.loop_min.orig = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       let sum.s1.r8$x.max_2 = sum.s1.r8$x
       let sum.s1.r8$x.min_2 = sum.s1.r8$x
       sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] + ((int32)weight[(0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.0)*weight.stride.pim.0)) + ((sum.s1.r8$x - weight.min.pim.1)*weight.stride.pim.1)]*(int32)vector[0 + ((sum.s1.r8$x - vector.min.pim.0)*vector.stride.pim.0)])
      }
     }
     consume sum {
      gemv[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_from(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Adding atomic mutex allocation...
Lowering after adding atomic mutex allocation: (unchanged)

Unpacking buffer arguments...
Lowering after unpacking buffer arguments:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.__bank_id_x.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.__bank_id_x.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.__bank_id_x.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.__thread_id_x.loop_extent = 16
 let gemv.s0.i.thread.thread.__thread_id_x.loop_max = 15
 let gemv.s0.i.thread.thread.__thread_id_x.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load(((((gemv.extent.0 + 2047)/2048)*1)*1)*1, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)vector.buffer, 0, ((weight.extent.1 + -1) - 0) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   for (ii1, 0, (weight.extent.1 + -1) + 1) {
    halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)weight.buffer, (ii1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)) + (((0*128) + 0) + gemv.s0.i.thread.base), ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   }
  }
  pim_bank<Default_PIM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let gemv.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let gemv.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let gemv.stride.pim.0 = 1
   let sum.min.pim.0 = sum.min.0
   let sum.extent.pim.0 = sum.extent.0
   let sum.stride.pim.0 = sum.stride.0
   let vector.min.pim.0 = 0
   let vector.extent.pim.0 = ((weight.extent.1 + -1) - 0) + 1
   let vector.stride.pim.0 = 1
   let weight.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let weight.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let weight.stride.pim.0 = 1
   let weight.min.pim.1 = 0
   let weight.extent.pim.1 = ((weight.extent.1 + -1) - 0) + 1
   let weight.stride.pim.1 = 1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   pim_thread<Default_PIM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread.__thread_id_x*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r8$x.loop_extent = weight.extent.1
     let sum.s1.r8$x.loop_max = weight.extent.1 + -1
     let sum.s1.r8$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = 0
      let sum.s1.r8$x.loop_min.orig = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       let sum.s1.r8$x.max_2 = sum.s1.r8$x
       let sum.s1.r8$x.min_2 = sum.s1.r8$x
       sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] + (weight[(0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.0)*weight.stride.pim.0)) + ((sum.s1.r8$x - weight.min.pim.1)*weight.stride.pim.1)]*vector[0 + ((sum.s1.r8$x - vector.min.pim.0)*vector.stride.pim.0)])
      }
     }
     consume sum {
      gemv[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_from(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Skipping rewriting memoized allocations...
Selecting a GPU API for GPU loops...
Lowering after selecting a GPU API:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
let gemv.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let gemv.s0.i.min = gemv.min.0
let sum.s1.r8$x.max = weight.extent.1 + -1
let sum.s1.r8$x.min = 0
let sum.s1.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s1.i.min = gemv.min.0
let sum.s0.i.max = (gemv.extent.0 + gemv.min.0) + -1
let sum.s0.i.min = gemv.min.0
let gemv.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let gemv.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let gemv.stride.0.required = 1
let vector.extent.0.required = ((weight.extent.1 + -1) + 1) - 0
let vector.min.0.required = 0
let vector.stride.0.required = 1
let weight.extent.0.required = ((((15*128) + 127) + ((gemv.extent.0 + gemv.min.0) + -2048)) + 1) - (((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048))
let weight.min.0.required = ((0*128) + 0) + ((min(gemv.extent.0, 2048) + gemv.min.0) + -2048)
let weight.stride.0.required = 1
let weight.extent.1.required = ((weight.extent.1 + -1) + 1) - 0
let weight.min.1.required = 0
let weight.stride.1.required = weight.stride.0.required*weight.extent.0.required
let gemv.stride.0.constrained = 1
let vector.stride.0.constrained = 1
let weight.stride.0.constrained = 1
let gemv.stride.0.proposed = 1
let gemv.min.0.proposed = gemv.min.0.required
let gemv.extent.0.proposed = gemv.extent.0.required
let vector.stride.0.proposed = 1
let vector.min.0.proposed = vector.min.0.required
let vector.extent.0.proposed = vector.extent.0.required
let weight.stride.0.proposed = 1
let weight.min.0.proposed = weight.min.0.required
let weight.extent.0.proposed = weight.extent.0.required
let weight.stride.1.proposed = weight.stride.1.required
let weight.min.1.proposed = weight.min.1.required
let weight.extent.1.proposed = weight.extent.1.required
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || ((gemv.min.0.proposed <= gemv.min.0.required) && (((gemv.min.0.proposed + gemv.extent.0.proposed) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Output buffer gemv", 0, gemv.min.0.proposed, (gemv.min.0.proposed + gemv.extent.0.proposed) - 1, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer) || ((vector.min.0.proposed <= vector.min.0.required) && (((vector.min.0.proposed + vector.extent.0.proposed) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer vector", 0, vector.min.0.proposed, (vector.min.0.proposed + vector.extent.0.proposed) - 1, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.0.proposed <= weight.min.0.required) && (((weight.min.0.proposed + weight.extent.0.proposed) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 0, weight.min.0.proposed, (weight.min.0.proposed + weight.extent.0.proposed) - 1, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1))
assert(!(uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((weight.min.1.proposed <= weight.min.1.required) && (((weight.min.1.proposed + weight.extent.1.proposed) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1))), halide_error_constraints_make_required_region_smaller("Input buffer weight", 1, weight.min.1.proposed, (weight.min.1.proposed + weight.extent.1.proposed) - 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1))
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(gemv.min.0.proposed, gemv.extent.0.proposed, gemv.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(vector.min.0.proposed, vector.extent.0.proposed, vector.stride.0.proposed, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct(weight.min.0.proposed, weight.extent.0.proposed, weight.stride.0.proposed, 0, weight.min.1.proposed, weight.extent.1.proposed, weight.stride.1.proposed, 0), (uint64)0)
}
if (!((((uint1)0 || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((gemv.min.0 <= gemv.min.0.required) && (((gemv.min.0 + gemv.extent.0) - 1) >= ((gemv.min.0.required + gemv.extent.0.required) - 1)), halide_error_access_out_of_bounds("Output buffer gemv", 0, gemv.min.0.required, (gemv.min.0.required + gemv.extent.0.required) - 1, gemv.min.0, (gemv.min.0 + gemv.extent.0) - 1))
 assert(gemv.extent.0 >= 0, halide_error_buffer_extents_negative("Output buffer gemv", 0, gemv.extent.0))
 assert((vector.min.0 <= vector.min.0.required) && (((vector.min.0 + vector.extent.0) - 1) >= ((vector.min.0.required + vector.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer vector", 0, vector.min.0.required, (vector.min.0.required + vector.extent.0.required) - 1, vector.min.0, (vector.min.0 + vector.extent.0) - 1))
 assert(vector.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= weight.min.0.required) && (((weight.min.0 + weight.extent.0) - 1) >= ((weight.min.0.required + weight.extent.0.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 0, weight.min.0.required, (weight.min.0.required + weight.extent.0.required) - 1, weight.min.0, (weight.min.0 + weight.extent.0) - 1))
 assert(weight.extent.0 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= weight.min.1.required) && (((weight.min.1 + weight.extent.1) - 1) >= ((weight.min.1.required + weight.extent.1.required) - 1)), halide_error_access_out_of_bounds("Input buffer weight", 1, weight.min.1.required, (weight.min.1.required + weight.extent.1.required) - 1, weight.min.1, (weight.min.1 + weight.extent.1) - 1))
 assert(weight.extent.1 >= 0, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == gemv.stride.0.constrained, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", gemv.stride.0.constrained))
 assert(vector.stride.0 == vector.stride.0.constrained, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", vector.stride.0.constrained))
 assert(weight.stride.0 == weight.stride.0.constrained, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", weight.stride.0.constrained))
 let gemv.total_extent.0 = int64(gemv.extent.0)
 let vector.total_extent.0 = int64(vector.extent.0)
 let weight.total_extent.0 = int64(weight.extent.0)
 let weight.total_extent.1 = int64(weight.extent.1)*weight.total_extent.0
 assert((uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", (uint64)abs(int64(gemv.extent.0)*int64(gemv.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", (uint64)abs(int64(vector.extent.0)*int64(vector.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.0)*int64(weight.stride.0.constrained)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 let gemv.s0.i.loop_max = (gemv.extent.0 + gemv.min.0) + -1
 let gemv.s0.i.loop_min = gemv.min.0
 let gemv.s0.i.loop_extent = gemv.extent.0
 let gemv.s0.i.block.__bank_id_x.loop_extent = (gemv.extent.0 + 2047)/2048
 let gemv.s0.i.block.__bank_id_x.loop_max = (gemv.extent.0 + -1)/2048
 let gemv.s0.i.block.__bank_id_x.loop_min = 0
 let gemv.s0.i.thread.loop_extent = 2048
 let gemv.s0.i.thread.loop_max = 2047
 let gemv.s0.i.thread.loop_min = 0
 let gemv.s0.i.thread.thread.__thread_id_x.loop_extent = 16
 let gemv.s0.i.thread.thread.__thread_id_x.loop_max = 15
 let gemv.s0.i.thread.thread.__thread_id_x.loop_min = 0
 let gemv.s0.i.thread.inner_loop.loop_extent = 128
 let gemv.s0.i.thread.inner_loop.loop_max = 127
 let gemv.s0.i.thread.inner_loop.loop_min = 0
 let gemv.s0.i.block.loop_min.orig = 0
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load(((((gemv.extent.0 + 2047)/2048)*1)*1)*1, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)vector.buffer, 0, ((weight.extent.1 + -1) - 0) + 1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   for (ii1, 0, (weight.extent.1 + -1) + 1) {
    halide_upmem_dpu_copy_to(dpu_idx, (struct halide_buffer_t *)weight.buffer, (ii1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)) + (((0*128) + 0) + gemv.s0.i.thread.base), ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let gemv.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let gemv.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let gemv.stride.pim.0 = 1
   let sum.min.pim.0 = sum.min.0
   let sum.extent.pim.0 = sum.extent.0
   let sum.stride.pim.0 = sum.stride.0
   let vector.min.pim.0 = 0
   let vector.extent.pim.0 = ((weight.extent.1 + -1) - 0) + 1
   let vector.stride.pim.0 = 1
   let weight.min.pim.0 = ((0*128) + 0) + gemv.s0.i.thread.base
   let weight.extent.pim.0 = ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1
   let weight.stride.pim.0 = 1
   let weight.min.pim.1 = 0
   let weight.extent.pim.1 = ((weight.extent.1 + -1) - 0) + 1
   let weight.stride.pim.1 = 1*(((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let gemv.s0.i.thread.inner_loop.base = gemv.s0.i.thread.thread.__thread_id_x*128
    let gemv.s0.i.thread.inner_loop.loop_min.orig = 0
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     let gemv.s0.i.thread = (gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop
     let gemv.s0.i = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let gemv.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.r8$x.max_1 = weight.extent.1 + -1
     let sum.s1.r8$x.min_1 = 0
     let sum.s1.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.max_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.min_1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.max_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.min_realized = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.i.extent_realized = 1
     let sum.extent.0 = sum.i.extent_realized
     let sum.min.0 = sum.i.min_realized
     let sum.stride.0 = 1
     allocate sum[int32 * sum.i.extent_realized]
     let sum.buffer = let t7 = (struct halide_dimension_t *)make_struct(sum.min.0, sum.extent.0, sum.stride.0, 0) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)alloca(size_of_halide_buffer_t()), t7, sum, (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, t7, (uint64)0)
     let sum.s0.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s0.i.loop_extent = 1
     let sum.s1.r8$x.loop_extent = weight.extent.1
     let sum.s1.r8$x.loop_max = weight.extent.1 + -1
     let sum.s1.r8$x.loop_min = 0
     let sum.s1.i.loop_max = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_min = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let sum.s1.i.loop_extent = 1
     let t2 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     let t1 = ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base
     produce sum {
      sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = 0
      let sum.s1.r8$x.loop_min.orig = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       let sum.s1.r8$x.max_2 = sum.s1.r8$x
       let sum.s1.r8$x.min_2 = sum.s1.r8$x
       sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)] + (weight[(0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - weight.min.pim.0)*weight.stride.pim.0)) + ((sum.s1.r8$x - weight.min.pim.1)*weight.stride.pim.1)]*vector[0 + ((sum.s1.r8$x - vector.min.pim.0)*vector.stride.pim.0)])
      }
     }
     consume sum {
      gemv[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - gemv.min.pim.0)*gemv.stride.pim.0)] = sum[0 + (((((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop) + gemv.s0.i.thread.base) - sum.min.pim.0)*sum.stride.pim.0)]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   let gemv.s0.i.thread.thread.loop_min.orig = 0
   let dpu_idx = gemv.s0.i.block.__bank_id_x
   halide_upmem_dpu_copy_from(dpu_idx, (struct halide_buffer_t *)gemv.buffer, ((0*128) + 0) + gemv.s0.i.thread.base, ((((((16 + 0) - 1)*128) + ((128 + 0) - 1)) + gemv.s0.i.thread.base) - (((0*128) + 0) + gemv.s0.i.thread.base)) + 1)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Injecting host <-> dev buffer copies...
Lowering after injecting host <-> dev buffer copies: (unchanged)

Selecting a GPU API for extern stages...
Lowering after selecting a GPU API for extern stages: (unchanged)

Simplifying...
Lowering after second simplifcation:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 0
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(int64(gemv.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(int64(gemv.extent.0)), (uint64)2147483647))
 assert(uint64(int64(vector.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(int64(vector.extent.0)), (uint64)2147483647))
 assert(uint64(int64(weight.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(int64(weight.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + gemv.s0.i.thread.base, 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Reduce prefetch dimension...
Lowering after reduce prefetch dimension: (unchanged)

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 0
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(int64(gemv.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(int64(gemv.extent.0)), (uint64)2147483647))
 assert(uint64(int64(vector.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(int64(vector.extent.0)), (uint64)2147483647))
 assert(uint64(int64(weight.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(int64(weight.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + gemv.s0.i.thread.base, 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Unrolling...
Lowering after unrolling: (unchanged)

Vectorizing...
Lowering after vectorizing:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + gemv.s0.i.thread.base, 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Detecting vector interleavings...
Lowering after rewriting vector interleavings:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + gemv.s0.i.thread.base, 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base = min(likely_if_innermost((gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0), (gemv.extent.0 + gemv.min.0) + -2048)
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, gemv.s0.i.thread.base, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Staging strided loads...
Lowering after staging strided loads: (unchanged)

Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Rebasing loops to zero...
Lowering after rebasing loops to zero:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}


Hoisting loop invariant if statements...
Lowering after hoisting loop invariant if statements: (unchanged)

Injecting early frees...
Lowering after injecting early frees:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
     free sum
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Simplifying correlated differences...
Lowering after simplifying correlated differences:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
     free sum
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Bounding small allocations...
Lowering after bounding small allocations:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
     free sum
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Simplifying...
Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 let t9 = max(gemv.extent.0, 2048) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t9, 1, 0, 0, weight.extent.1, t9, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert((2048 <= gemv.extent.0) && (((max(gemv.extent.0, 2048) + (min(gemv.extent.0, 2048) + gemv.min.0)) + -2048) <= (gemv.extent.0 + gemv.min.0)), let t10 = (min(gemv.extent.0, 2048) + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, t10 + -2048, (max(gemv.extent.0, 2048) + t10) + -2049, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  for (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + (gemv.min.0 + gemv.s0.i.thread.base.s), 2048)
   }
  }
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, (gemv.extent.0 + 2047)/2048) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + ((gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop)]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[(gemv.s0.i.thread.thread.__thread_id_x*128) + gemv.s0.i.thread.inner_loop] = sum[0]
     }
     free sum
    }
   }
  }
  for (gemv.s0.i.block.__bank_id_x, 0, gemv.extent.0/2048) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Flattening nested ramps...
Lowering after flattening nested ramps: (unchanged)

Removing dead allocations and moving loop invariant code...
Lowering after removing dead allocations and hoisting loop invariants:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0, 0, weight.extent.1, max(gemv.extent.0, 2048), 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, (gemv.extent.0 + gemv.min.0) + -1, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t13 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t13) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let t14 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t14) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  let t15 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t15) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   let t16 = gemv.min.0 + gemv.s0.i.thread.base.s
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + t16, 2048)
   }
  }
  let t17 = (gemv.extent.0 + 2047)/2048
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t17) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let t18 = gemv.s0.i.thread.thread.__thread_id_x*128
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t19 = gemv.s0.i.thread.inner_loop + t18
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + t19]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t18] = sum[0]
     }
     free sum
    }
   }
  }
  let t20 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t20) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Finding intrinsics...
Lowering after finding intrinsics:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 let t21 = max(gemv.extent.0, 2048) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t21, 1, 0, 0, weight.extent.1, t21, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t22 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t22 + -1, gemv.min.0, t22 + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t13 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t13) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let t14 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t14) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  let t15 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t15) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   let t16 = gemv.min.0 + gemv.s0.i.thread.base.s
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + t16, 2048)
   }
  }
  let t17 = (gemv.extent.0 + 2047)/2048
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t17) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let t18 = gemv.s0.i.thread.thread.__thread_id_x*128
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t19 = gemv.s0.i.thread.inner_loop + t18
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + t19]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t18] = sum[0]
     }
     free sum
    }
   }
  }
  let t20 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t20) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Hoisting prefetches...
Lowering after hoisting prefetches:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 let t21 = max(gemv.extent.0, 2048) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t21, 1, 0, 0, weight.extent.1, t21, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t22 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t22 + -1, gemv.min.0, t22 + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t13 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t13) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let t14 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t14) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  let t15 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t15) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   let t16 = gemv.min.0 + gemv.s0.i.thread.base.s
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + t16, 2048)
   }
  }
  let t17 = (gemv.extent.0 + 2047)/2048
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t17) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let t18 = gemv.s0.i.thread.thread.__thread_id_x*128
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t19 = gemv.s0.i.thread.inner_loop + t18
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + t19]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t18] = sum[0]
     }
     free sum
    }
   }
  }
  let t20 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t20) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}

Lowering after final simplification:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 let t21 = max(gemv.extent.0, 2048) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t21, 1, 0, 0, weight.extent.1, t21, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t22 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t22 + -1, gemv.min.0, t22 + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t13 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t13) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let t14 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t14) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  let t15 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t15) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   let t16 = gemv.min.0 + gemv.s0.i.thread.base.s
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + t16, 2048)
   }
  }
  let t17 = (gemv.extent.0 + 2047)/2048
  pim_bank<UPMEM> (gemv.s0.i.block.__bank_id_x, 0, t17) {
   pim_thread<UPMEM> (gemv.s0.i.thread.thread.__thread_id_x, 0, 16) {
    let t18 = gemv.s0.i.thread.thread.__thread_id_x*128
    for (gemv.s0.i.thread.inner_loop, 0, 128) {
     allocate sum[int32 * 1]
     produce sum {
      sum[0] = 0
      let t19 = gemv.s0.i.thread.inner_loop + t18
      for (sum.s1.r8$x, 0, weight.extent.1) {
       sum[0] = sum[0] + (weight[(sum.s1.r8$x*2048) + t19]*vector[sum.s1.r8$x])
      }
     }
     consume sum {
      gemv[gemv.s0.i.thread.inner_loop + t18] = sum[0]
     }
     free sum
    }
   }
  }
  let t20 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t20) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}


Skipping Hexagon offload...
Skipping GPU offload...
Offloading PIM loops...
Kernel launch: gemv.s0.i.block.__bank_id_x
Kernel bounds: (16) threads, (t17, 1, 1, 1) banks
var: weight.extent.1
buffer: gemv 0 (write) dims=0
buffer: vector 0 (read) dims=0
buffer: weight 0 (read) dims=0
CodeGen_UPMEM_DPU_Dev::compile_kernel_gemv_s0_i_block___bank_id_x
UPMEM kernel:
_0 = _gemv_s0_i_thread_thread___thread_id_x * 128;
for (int _gemv_s0_i_thread_inner_loop = 0; _gemv_s0_i_thread_inner_loop < 0 + 128; _gemv_s0_i_thread_inner_loop++)
{
 {
  _sum[1];
  // produce sum
  _sum[0] = 0;
  _1 = _gemv_s0_i_thread_inner_loop + _0;
  for (int _sum_s1_r8__x = 0; _sum_s1_r8__x < 0 + _weight_extent_1; _sum_s1_r8__x++)
  {
   _2 = _sum[0];
   _3 = _sum_s1_r8__x * 2048;
   _4 = _3 + _1;
   _5 = (( *)_weight)[_4];
   _6 = (( *)_vector)[_sum_s1_r8__x];
   _7 = _5 * _6;
   _8 = _2 + _7;
   _sum[0] = _8;
  } // for _sum_s1_r8__x
  // consume sum
  _9 = _sum[0];
  _10 = _gemv_s0_i_thread_inner_loop + _0;
  (( *)_gemv)[_10] = _9;
 } // alloc _sum
} // for _gemv_s0_i_thread_inner_loop

Lowering after splitting off PIM loops:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 let t21 = max(gemv.extent.0, 2048) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t21, 1, 0, 0, weight.extent.1, t21, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t22 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t22 + -1, gemv.min.0, t22 + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t13 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t13) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let t14 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t14) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  let t15 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t15) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   let t16 = gemv.min.0 + gemv.s0.i.thread.base.s
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + t16, 2048)
   }
  }
  let t17 = (gemv.extent.0 + 2047)/2048
  let halide_upmem_run_result = halide_upmem_run(((void *))upmem[0], "_kernel_gemv_s0_i_block___bank_id_x", t17, 1, 1, 16, 0, (void *)make_struct((uint32)73728, (uint32)73728, (uint32)73728, (uint32)73728, (uint32)0), (void *)make_struct((void *)gemv.buffer, (void *)vector.buffer, (void *)weight.buffer, (void *)make_struct(weight.extent.1), reinterpret<(void *)>((uint64)0)), (void *)make_struct((uint8)1, (uint8)1, (uint8)1, (uint8)0, (uint8)0))
  assert(halide_upmem_run_result == 0, halide_upmem_run_result)
  let t20 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t20) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}


Lowering Parallel Tasks...
Lowering after generating parallel tasks and closures:
assert(reinterpret<uint64>((struct halide_buffer_t *)weight.buffer) != (uint64)0, halide_error_buffer_argument_is_null("weight"))
assert(reinterpret<uint64>((struct halide_buffer_t *)vector.buffer) != (uint64)0, halide_error_buffer_argument_is_null("vector"))
assert(reinterpret<uint64>((struct halide_buffer_t *)gemv.buffer) != (uint64)0, halide_error_buffer_argument_is_null("gemv"))
let gemv = (void *)_halide_buffer_get_host((struct halide_buffer_t *)gemv.buffer)
let gemv.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)gemv.buffer)
let gemv.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)gemv.buffer)
let gemv.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)gemv.buffer, 0)
let gemv.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)gemv.buffer, 0)
let vector = (void *)_halide_buffer_get_host((struct halide_buffer_t *)vector.buffer)
let vector.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)vector.buffer)
let vector.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)vector.buffer)
let vector.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)vector.buffer, 0)
let vector.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)vector.buffer, 0)
let vector.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)vector.buffer, 0)
let weight = (void *)_halide_buffer_get_host((struct halide_buffer_t *)weight.buffer)
let weight.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)weight.buffer)
let weight.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)weight.buffer)
let weight.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 0)
let weight.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 0)
let weight.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 0)
let weight.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)weight.buffer, 1)
let weight.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)weight.buffer, 1)
let weight.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)weight.buffer, 1)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)gemv.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)gemv.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, max(gemv.extent.0, 2048), 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)vector.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)vector.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 1, (struct halide_dimension_t *)make_struct(0, weight.extent.1, 1, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer)) {
 let t21 = max(gemv.extent.0, 2048) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)weight.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)weight.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 0, 32, 2, (struct halide_dimension_t *)make_struct((min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t21, 1, 0, 0, weight.extent.1, t21, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)weight.buffer) || ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)gemv.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)vector.buffer)))) {
 assert(gemv.type == (uint32)73728, halide_error_bad_type("Output buffer gemv", gemv.type, (uint32)73728))
 assert(gemv.dimensions == 1, halide_error_bad_dimensions("Output buffer gemv", gemv.dimensions, 1))
 assert(vector.type == (uint32)73728, halide_error_bad_type("Input buffer vector", vector.type, (uint32)73728))
 assert(vector.dimensions == 1, halide_error_bad_dimensions("Input buffer vector", vector.dimensions, 1))
 assert(weight.type == (uint32)73728, halide_error_bad_type("Input buffer weight", weight.type, (uint32)73728))
 assert(weight.dimensions == 2, halide_error_bad_dimensions("Input buffer weight", weight.dimensions, 2))
 assert(2048 <= gemv.extent.0, let t22 = (gemv.extent.0 + gemv.min.0) in halide_error_access_out_of_bounds("Output buffer gemv", 0, (min(gemv.extent.0, 2048) + gemv.min.0) + -2048, t22 + -1, gemv.min.0, t22 + -1))
 assert((vector.min.0 <= 0) && (weight.extent.1 <= (vector.extent.0 + vector.min.0)), halide_error_access_out_of_bounds("Input buffer vector", 0, 0, weight.extent.1 + -1, vector.min.0, (vector.extent.0 + vector.min.0) + -1))
 assert(0 <= vector.extent.0, halide_error_buffer_extents_negative("Input buffer vector", 0, vector.extent.0))
 assert((weight.min.0 <= gemv.min.0) && ((gemv.extent.0 + gemv.min.0) <= (weight.extent.0 + weight.min.0)), halide_error_access_out_of_bounds("Input buffer weight", 0, gemv.min.0, (gemv.extent.0 + gemv.min.0) + -1, weight.min.0, (weight.extent.0 + weight.min.0) + -1))
 assert(0 <= weight.extent.0, halide_error_buffer_extents_negative("Input buffer weight", 0, weight.extent.0))
 assert((weight.min.1 <= 0) && (0 <= weight.min.1), halide_error_access_out_of_bounds("Input buffer weight", 1, 0, weight.extent.1 + -1, weight.min.1, (weight.extent.1 + weight.min.1) + -1))
 assert(0 <= weight.extent.1, halide_error_buffer_extents_negative("Input buffer weight", 1, weight.extent.1))
 assert(gemv.stride.0 == 1, halide_error_constraint_violated("gemv.stride.0", gemv.stride.0, "1", 1))
 assert(vector.stride.0 == 1, halide_error_constraint_violated("vector.stride.0", vector.stride.0, "1", 1))
 assert(weight.stride.0 == 1, halide_error_constraint_violated("weight.stride.0", weight.stride.0, "1", 1))
 let weight.total_extent.1 = int64(weight.extent.1)*int64(weight.extent.0)
 assert(uint64(gemv.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("gemv", uint64(gemv.extent.0), (uint64)2147483647))
 assert(uint64(vector.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("vector", uint64(vector.extent.0), (uint64)2147483647))
 assert(uint64(weight.extent.0) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", uint64(weight.extent.0), (uint64)2147483647))
 assert((uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("weight", (uint64)abs(int64(weight.extent.1)*int64(weight.stride.1)), (uint64)2147483647))
 assert(weight.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("weight", weight.total_extent.1, (int64)2147483647))
 produce gemv {
  let halide_upmem_alloc_load_result = halide_upmem_alloc_load((gemv.extent.0 + 2047)/2048, "kernel_0")
  assert(halide_upmem_alloc_load_result == 0, halide_upmem_alloc_load_result)
  let t13 = gemv.extent.0/2048.
  for (gemv.s0.i.block.__bank_id_x, 0, t13) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_to(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let t14 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t14) {
   halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)vector.buffer, 0, weight.extent.1)
  }
  let t15 = (gemv.extent.0 + 2047)/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t15) {
   let gemv.s0.i.thread.base.s = min(gemv.s0.i.block.__bank_id_x*2048, gemv.extent.0 + -2048)
   let t16 = gemv.min.0 + gemv.s0.i.thread.base.s
   for (ii1, 0, weight.extent.1) {
    halide_upmem_dpu_copy_to(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)weight.buffer, (ii1*2048) + t16, 2048)
   }
  }
  let t17 = (gemv.extent.0 + 2047)/2048
  let halide_upmem_run_result = halide_upmem_run(((void *))upmem[0], "_kernel_gemv_s0_i_block___bank_id_x", t17, 1, 1, 16, 0, (void *)make_struct((uint32)73728, (uint32)73728, (uint32)73728, (uint32)73728, (uint32)0), (void *)make_struct((void *)gemv.buffer, (void *)vector.buffer, (void *)weight.buffer, (void *)make_struct(weight.extent.1), reinterpret<(void *)>((uint64)0)), (void *)make_struct((uint8)1, (uint8)1, (uint8)1, (uint8)0, (uint8)0))
  assert(halide_upmem_run_result == 0, halide_upmem_run_result)
  let t20 = gemv.extent.0/2048
  for (gemv.s0.i.block.__bank_id_x, 0, t20) {
   halide_upmem_dpu_copy_from(gemv.s0.i.block.__bank_id_x, (struct halide_buffer_t *)gemv.buffer, (gemv.s0.i.block.__bank_id_x*2048) + gemv.min.0, 2048)
  }
  if ((gemv.extent.0 % 2048) != 0) {
   halide_upmem_dpu_copy_from(gemv.extent.0/2048, (struct halide_buffer_t *)gemv.buffer, (gemv.extent.0 + gemv.min.0) + -2048, 2048)
  }
  let halide_upmem_free_result = halide_upmem_free("kernel_0")
  assert(halide_upmem_free_result == 0, halide_upmem_free_result)
 }
}


Module.compile(): c_upmem AOT_result/gemv_generate
dir_rmdir: /tmp/SR1GlG
